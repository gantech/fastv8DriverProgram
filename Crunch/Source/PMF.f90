MODULE PMFSubs

   ! This module contains the routines needed to compute probability-mass functions.

IMPLICIT NONE

CONTAINS

!=======================================================================
   SUBROUTINE PMF ( Fi )


      ! This routine generates the PMFs.


   USE                             DataMod
   USE                             ProgGen


      ! Argument declarations.

   INTEGER, INTENT(IN)          :: Fi


      ! Local declarations.

   INTEGER                      :: Fil
   INTEGER                      :: IB
   INTEGER                      :: IC
   INTEGER                      :: IR
   INTEGER                      :: PC



      ! Initialize the aggregrate PMFs.

   CALL PMFInit ( Fi )

   CALL WrScr ( '  Computing PMFs.' )


      ! Are we doing aggregates?  If so, process data for all files.

   IF ( Aggregate )  THEN


         ! Let's process all the data files.

      DO Fil=1,GoodFiles


            ! Fill the bins.

         DO IR=1,NumRecs

            DO IC=1,NumPMF

               PC = PMFCols(IC)
               IB = MIN( INT( PMFInvDel(IC)*( ConvData(PC,IR,Fil) - PMFMins(IC) ) ) + 1 , NumPMFBins )

               PMFCnt(IC,IB) = PMFCnt(IC,IB) + 1

            ENDDO ! IC

         ENDDO ! IR

      ENDDO ! Fi


   ELSE


         ! Fill the bins for this individual PMF.

      DO IR=1,NumRecs

         DO IC=1,NumPMF

            PC = PMFCols(IC)
            IB = MIN( INT( PMFInvDel(IC)*( ConvData(PC,IR,Fi) - PMFMins(IC) ) ) + 1 , NumPMFBins )
            PMFCnt(IC,IB) = PMFCnt(IC,IB) + 1

         ENDDO ! IC

      ENDDO ! IR


   ENDIF


      ! Output the PMFs.

   CALL PMFOut


   RETURN
   END SUBROUTINE PMF ! ( Fi )
!=======================================================================
   SUBROUTINE PMFInit ( Fi )


      ! This routine creates the PMF file and initializes the PMF arrays.


   USE                             DataMod
   USE                             ProgGen


      ! Argument declarations.

   INTEGER, INTENT(IN)          :: Fi


      ! Local declarations.

   INTEGER                      :: Fil
   INTEGER                      :: IB
   INTEGER                      :: IC
   INTEGER                      :: IOS
   INTEGER                      :: PC

   CHARACTER(200)               :: Frmt
   CHARACTER(100)               :: PMFFile



      ! Get date and time for PMF file.

   DateStr = CurDate()
   TimeStr = CurTime()


      ! Create the name for the PMF file.

   IF ( Aggregate )  THEN
      Fil      = 1
      PMFFile = TRIM( AggRoot )//'.pmf'
   ELSE
      Fil      = Fi
      PMFFile = TRIM( RootName(Fi) )//'.pmf'
   ENDIF


      ! Open the PMF file.

   CALL GetNewUnit ( HU )
   OPEN ( HU , FILE=Trim( PMFFile ) , STATUS='UNKNOWN' , FORM='FORMATTED' , IOSTAT=IOS )

   IF ( IOS /= 0 )  THEN
      CALL ProgAbort ( ' Warning.  The PMF file "'//Trim( PMFFile )//'" could not be opened.')
   ENDIF


      ! Write the appropriate header for aggregate or individual PMFs.

   Frmt = "( / 'PMFs generated by ' , A , A , ' on ' , A , ' at ' , A , '.' )"
   WRITE (HU,Frmt)  TRIM( ProgName ), TRIM( ProgVer ), DateStr, TimeStr

   IF ( Aggregate )  THEN
      Frmt = "( / 'These aggregate PMFs were based upon ' , A , ' records from ' , A "&
           //" , ' of the ' , A , ' specified input files.' )"
      WRITE (HU,Frmt)  TRIM( Int2LStr( AnalRecs ) ), TRIM( Int2LStr( GoodFiles ) ), TRIM( Int2LStr( NumFiles ) )
   ELSE
      Frmt = "( / 'These PMFs for ""' , A , '"" were based upon ' , A , ' records.' )"
      WRITE (HU,Frmt)  TRIM( FileName(Fi) ), TRIM( Int2LStr( AnalRecs ) )
   ENDIF


      ! Let folks know if we used the peak finder.

   IF ( Do_PF )  THEN
     WRITE (HU,'(A)')  'The peak-finding algorithm was used.'
   ELSE
     WRITE (HU,'(A)')  'The peak-finding algorithm was not used.'
   ENDIF


      ! Write out mean wind speed and turbulence intensity.

   IF ( WS_Col > 0 )  THEN

      IF ( HaveUnits )  THEN
         WRITE (HU,'(/,A,F5.1,1X,A,/,A,F5.1,A)')  'Mean wind speed      =', MeanWs(Fil), Units(WS_Col), &
                                                  'Turbulence intensity =', TrbInt(Fil), '%'
      ELSE
         WRITE (HU,'(/,A,F5.1,/,A,F5.1,A)')  'Mean wind speed      =', MeanWs(Fil), &
                                             'Turbulence intensity =', TrbInt(Fil), '%'
      ENDIF

   ENDIF


      ! Write the column headings.

   IF ( TabDelim )  THEN

      Frmt = "(/,   (A,'[X]"//Tab//"',A,'[Y]',:,'"//Tab//"'))"
      WRITE (Frmt(4:6),'(I3)')  NumPMF
      WRITE (HU,Frmt)  ( TRIM( Titles(PMFCols(IC)) ), TRIM( Titles(PMFCols(IC)) ), IC=1,NumPMF )

      IF ( HaveUnits )  THEN
         Frmt = "(   (A,'"//Tab//"',A,:,'"//Tab//"'))"
         WRITE (Frmt(2:4),'(I3)')  NumPMF
         WRITE (HU,Frmt)  ( TRIM( Units(PMFCols(IC)) ), '1/'//TRIM( Units(PMFCols(IC)) ), IC=1,NumPMF )
      ENDIF

   ELSE

      Frmt = "(/,   ("//TextFmt//",'[X]',"//TextFmt//",'[Y]'))"
      WRITE (Frmt(4:6),'(I3)')  NumPMF
      WRITE (HU,Frmt)  ( ADJUSTR( TRIM( Titles(PMFCols(IC)) ) ), &
                         ADJUSTR( TRIM( Titles(PMFCols(IC)) ) ), IC=1,NumPMF )

      IF ( HaveUnits )  THEN
         Frmt = "(   (3X,"//TextFmt//",1X,"//TextFmtI//"))"
         WRITE (Frmt(2:4),'(I3)')  NumPMF
         WRITE (HU,Frmt)  ( ADJUSTR( Units(PMFCols(IC)) ), ADJUSTR( '1/'//TRIM( Units(PMFCols(IC)) ) ), IC=1,NumPMF )
      ENDIF

      Frmt = "(   ("//TextFmt//",'---',"//TextFmt//",'---'))"
      WRITE (Frmt(2:4),'(I3)')  NumPMF
      WRITE (HU,Frmt)  ( '----------', '------------', IC=1,NumPMF )

   ENDIF


      ! Initialize arrays.

   DO IC=1,NumPMF

      DO IB=1,NumPMFBins
         PMFCnt(IC,IB) = 0
      ENDDO ! IB


         ! Compute inverse deltas and normalizing constants.
         ! Take special precautions if we have constant data.

      IF ( PMFAutoScl(IC) )  THEN

         PC = PMFCols(IC)

         PMFMins(IC) = DataMins(PC,Fi)
         PMFMaxs(IC) = DataMaxs(PC,Fi)


            ! See if we have constant data.

         IF ( PMFMins(IC) == PMFMaxs(IC) )  THEN


               ! Because we have constant data, we can choose our min and max for binning.
               ! We will make it so all the data ends up near the middle bin.

            IF( PMFMins(IC) == 0.0 )  THEN


                  ! For a constant zero, let's make it symmetrical about zero.
                  ! Deal with odd/even number of bins.

               IF( MODULO(NumPMFBins,2) == 0 ) THEN
                  PMFMins(IC) = -0.5*NumPMFBins
                  PMFInvDel(IC) =  1.0
               ELSE
                  PMFMins(IC) = -0.5*( 1 - NumPMFBins )
                  PMFInvDel(IC) =  1.0
               ENDIF

            ELSEIF( PMFMins(IC) < 0.0)  THEN


                  ! For a constant negative, let's make the min be minus twice the value.
                  ! Make the max be zero.  Deal with odd/even number of bins.

               PMFMins(IC) = 2.0*PMFMins(IC)

               IF( MODULO(NumPMFBins,2) == 0 )  THEN
                  PMFInvDel(IC) = -NumPMFBins/PMFMins(IC)
               ELSE
                  PMFInvDel(IC) = ( 1 - NumPMFBins)/PMFMins(IC)
               ENDIF

            ELSE


                  ! For a constant positive, let's make the max be twice the value.
                  ! Make the min be zero.  Deal with odd/even number of bins.

               IF( MODULO(NumPMFBins,2) == 0 )  THEN
                  PMFInvDel(IC) = 0.5*NumPMFBins/PMFMins(IC)
               ELSE
                  PMFInvDel(IC) = 0.5*( NumPMFBins - 1 )/PMFMins(IC)
               ENDIF

               PMFMins(IC) = 0.0

            ENDIF

            PMFNorm(IC) = PMFInvDel(IC)/AnalRecs

         ELSE


               ! Let's make it so the bins are evenly distributed from the
               ! calculated min to the calculated max.

            PMFInvDel(IC) = NumPMFBins/( PMFMaxs(IC) - PMFMins(IC) )
            PMFNorm(IC)   = PMFInvDel(IC)/AnalRecs

         ENDIF

      ELSE


            ! Let's make it so the bins are evenly distributed from the
            ! user-specified min to the user-specified max.

         PMFInvDel(IC) = NumPMFBins/( PMFMaxs(IC) - PMFMins(IC) )
         PMFNorm  (IC) = PMFInvDel(IC)/AnalRecs

      ENDIF

   ENDDO ! IC


   RETURN
   END SUBROUTINE PMFInit ! ( Fi )
!=======================================================================
   SUBROUTINE PMFOut


      ! This routine writes the PMFs.


   USE                             CrunchIO
   USE                             DataMod
   USE                             ProgGen


      ! Local declarations.

   INTEGER                      :: IB
   INTEGER                      :: IC

   CHARACTER(50)                :: Frmt



      ! Create the output format.

   IF ( TabDelim )  THEN
      Frmt = "(   ("//RealFmt//",:,'"//Tab//"'))"
   ELSE
      Frmt = "(   (3X,"//RealFmt//"))"
   ENDIF

   WRITE (Frmt(2:4),'(I3)')  2*NumPMF


      ! Write out the PMFs.

   DO IB=1,NumPMFBins

      DO IC=1,NumPMF
        PMFBinVal(IC) = ( IB - 0.5 )/PMFInvDel(IC) + PMFMins(IC)
      ENDDO ! IC

      WRITE (HU,Frmt)  ( PMFBinVal(IC), PMFNorm(IC)*PMFCnt(IC,IB), IC=1,NumPMF )

   ENDDO ! IB


      ! If all of the requested input files could not be read for aggregate analyses,
      ! append the list of bad files to the output.

   IF ( Aggregate .AND. ( BadFiles > 0 ) )  CALL WrBadList ( HU )


      ! Close the PMF file.

   CLOSE ( HU )


   RETURN
   END SUBROUTINE PMFOut
!=======================================================================

END MODULE PMFSubs
