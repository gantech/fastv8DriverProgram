MODULE ExtrValuSubs

   ! This module contains routines to extrapolate extremes.

CONTAINS

!=======================================================================
   SUBROUTINE ExtrapOpen (IC)


      ! This routine opens the extrapolation output files and (if appropriate) starts them
      ! with headers.


   USE                             CrunchIO
   USE                             DataMod
   USE                             ProgGen


      ! Argument declarations.

   INTEGER, INTENT(IN)          :: IC


      ! Local declarations.

   REAL(ReKi)                   :: ExtrapMax  (4)
   REAL(ReKi)                   :: ExtrapMin  (4)
   REAL(ReKi),ALLOCATABLE       :: MaxDist    (:)
   REAL(ReKi),ALLOCATABLE       :: MaxErrDist (:)
   REAL(ReKi)                   :: MaxErrVar  (4)
   REAL(ReKi)                   :: MaxStdErr  (4)
   REAL(ReKi)                   :: MaxVar     (4)
   REAL(ReKi),ALLOCATABLE       :: MinDist    (:)
   REAL(ReKi),ALLOCATABLE       :: MinErrDist (:)
   REAL(ReKi)                   :: MinErrVar  (4)
   REAL(ReKi)                   :: MinStdErr  (4)
   REAL(ReKi)                   :: MinVar     (4)
   REAL(ReKi)                   :: Quantile
   REAL(ReKi),ALLOCATABLE       :: SortMaxs   (:)
   REAL(ReKi),ALLOCATABLE       :: SortMins   (:)

   INTEGER                      :: ES_Col
   INTEGER                      :: IExt
   INTEGER                      :: IFi
   INTEGER                      :: IOS
   INTEGER                      :: IQ
   INTEGER                      :: Sttus
   INTEGER                      :: Unit

   CHARACTER( 15)               :: FltStr
   CHARACTER(200)               :: FormStr
   CHARACTER( 70)               :: Frmt
   CHARACTER( 17)               :: Titl



      ! Allocate some array space.

   ALLOCATE ( SortMaxs(GoodFiles) , STAT=Sttus )

   IF ( Sttus /= 0 )  THEN
      CALL ProgAbort ( ' Error allocating memory for the extrapolation SortMaxs array.' )
   ENDIF

   ALLOCATE ( SortMins(GoodFiles) , STAT=Sttus )

   IF ( Sttus /= 0 )  THEN
      CALL ProgAbort ( ' Error allocating memory for the extrapolation SortMins array.' )
   ENDIF

   ALLOCATE ( MaxDist(GoodFiles) , STAT=Sttus )

   IF ( Sttus /= 0 )  THEN
      CALL ProgAbort ( ' Error allocating memory for the extrapolation MaxDist array.' )
   ENDIF

   ALLOCATE ( MinDist(GoodFiles) , STAT=Sttus )

   IF ( Sttus /= 0 )  THEN
      CALL ProgAbort ( ' Error allocating memory for the extrapolation MinDist array.' )
   ENDIF

   ALLOCATE ( MaxErrDist(GoodFiles) , STAT=Sttus )

   IF ( Sttus /= 0 )  THEN
      CALL ProgAbort ( ' Error allocating memory for the extrapolation MaxErrDist array.' )
   ENDIF

   ALLOCATE ( MinErrDist(GoodFiles) , STAT=Sttus )

   IF ( Sttus /= 0 )  THEN
      CALL ProgAbort ( ' Error allocating memory for the extrapolation MinErrDist array.' )
   ENDIF



      ! Tell them why we're here.

   ES_Col = ES_Cols(IC)

   CALL WrScr1 ( ' =======================================================' )
   CALL WrScr ( ' Extrapolating values for '//TRIM(Titles(ES_Col))//'.' )


      ! Check if extrapolation is possible

   IF ( ExtHrs(IC) * 60.0 * 60.0 <= ConvData(TimeCol,NumRecs,1) - TStart ) THEN
      CALL UsrAlarm
      CALL WrScr ( ' Extrapolation time for '//TRIM(Titles(ES_Col))//' is too small.' )
      CALL WrScr ( ' Aborting extrapolation of this column.' )
      RETURN
   ENDIF


      ! Get date and time for summary files.

   DateStr = CurDate()
   TimeStr = CurTime()


      ! Open each of the extrapolation files.

   Unit = IC + 20

   IF ( ES_Col > NumCols )  THEN
      IF ( ES_Col > NumCols+NumAACols )  THEN
         Titl = TRIM( Titles(ES_Col) )//'-aa.ext'
      ELSE
         Titl = TRIM( Titles(ES_Col) )//'_aa.ext'
      ENDIF
   ELSE
      Titl = TRIM( Titles(ES_Col) )//'.ext'
   ENDIF

   OPEN ( Unit, FILE=TRIM( Titl ), STATUS='UNKNOWN', FORM='FORMATTED', IOSTAT=IOS )

   IF ( IOS /= 0 )  THEN
      CALL ProgAbort ( ' Warning.  The extrapolation file "'//Trim( Titl )//'" could not be opened.')
   END IF


      ! Create the header.

   IF ( HaveUnits )  THEN
      FormStr = '( / ''The extrapolation values for "'', 2A, ''" were generated by '', A, A, '' on '', A, '' at '', A, ''.'' )'
      WRITE (Unit,FormStr)   TRIM( Titles(ES_Col) ), TRIM( Units(ES_Col) ), &
                             TRIM( ProgName), TRIM( ProgVer ), DateStr, TimeStr
   ELSE
      FormStr = '( / ''The extrapolation values for "'',  A ,''" were generated by '', A, A, '' on '', A, '' at '', A ,''.'' )'
      WRITE (Unit,FormStr)   TRIM( Titles(ES_Col) ), &
                             TRIM( ProgName), TRIM( ProgVer ), DateStr, TimeStr

   ENDIF

   IF ( Do_PF )  THEN
     WRITE (Unit,'(A)')  'The peak-finding algorithm was used.'
   ELSE
     WRITE (Unit,'(A)')  'The peak-finding algorithm was not used.'
   ENDIF

   IF (ES_Col > NumCols .AND. ES_Col <= NumCols+NumAACols) THEN
     WRITE (Unit,'(A)')  'Azimuth binning was used in the analysis.'
   ELSE
     WRITE (Unit,'(A)')  'Azimuth binning was not used in the analysis.'
   ENDIF


   FltStr = Flt2LStr( (ConvData(TimeCol,NumRecs,1) - TStart)/60.0 )


      ! Extrapolate the maximum value.

   Call Extrap2  (IC, 1.0, ExtrapMax, MaxStdErr, MaxVar, MaxErrVar, MaxDist, MaxErrDist)

      ! Extrapolate the minimum value.

   Call Extrap2  (IC, -1.0, ExtrapMin, MinStdErr, MinVar, MinErrVar, MinDist, MinErrDist)

   DO IExt=1,4

      IF (IExt == 1) THEN !These are the expected values during the base period

         FormStr = '( // "Values during the base period of " , A , " seconds: " )'
         WRITE (Unit,FormStr) Trim( Flt2LStr( ConvData(TimeCol,NumRecs,1) - TStart ) )


      ELSEIF (IExt == 2) THEN !These are the requested quantile values

         FormStr = '( // "Values for the " , A , "% quantile for the basis period of ",A , " seconds: " )'

         WRITE (Unit,FormStr) Trim( Flt2LStr( Quant(IC) * 100.0) ), &
                Trim( Flt2LStr( ConvData(TimeCol,NumRecs,1) - TStart ) )


      ELSEIF (IExt == 3) THEN !These are the T extrapolation values

         IF ( BadFiles == 0 )  THEN

            IF ( TRIM ( FltStr ) == '1' )  THEN
               FormStr = "( // 'Extrapolation to ' , A , ' hours based on ' , A , ' data sets of ' , A , '-minute each.' )"
            ELSE
               FormStr = "( // 'Extrapolation to ' , A , ' hours based on ' , A , ' data sets of ' , A , '-minutes each.' )"
            ENDIF

            WRITE (Unit,FormStr)  TRIM( Flt2LStr( ExtHrs(IC) ) ), &
                TRIM( Int2LStr( GoodFiles ) ), TRIM( FltStr )

         ELSE

            IF ( TRIM ( FltStr ) == '1' )  THEN
               FormStr = "( // 'Extrapolation to ', A, ' hours based on ', A, ' of ', A, ' requested data sets of ', A, " &
                       //"'-minute each.' )"
            ELSE
               FormStr = "( // 'Extrapolation to ', A, ' hours based on ', &A, ' of ', A, ' requested data sets of ', A, " &
                       //"'-minutes each.' )"
            ENDIF

            WRITE (Unit,FormStr)  TRIM( Flt2LStr( ExtHrs(IC) ) ), &
                TRIM( Int2LStr( GoodFiles ) ), TRIM( Int2LStr( NumFiles ) ), TRIM( FltStr )

         ENDIF

         FormStr = '( / '' Expected values during a period of '' , A , '' times the basis period using "N"-extrapolation: '' )'

         WRITE (Unit,FormStr) Trim( Flt2LStr( ExtHrs(IC)*3600.0/( ConvData(TimeCol,NumRecs,1) - TStart ) ) )


      ELSEIF (IExt == 4) THEN !These are the N extrapolation values

         FormStr = '( / '' Expected values during a period of '' , A , '' times the basis period using "T"-extrapolation: '' )'
         WRITE (Unit,FormStr) Trim( Flt2LStr( ExtHrs(IC)*3600.0/&
              ( ConvData(TimeCol,NumRecs,1) - TStart ) ) )

      ENDIF


         ! Write out the estimated maximum and minimum in appropriate format.

      IF ( TabDelim )  THEN

         FormStr = "(  '"//Tab//"ExpectedVal"//Tab//"StdErr"//Tab//"Variance"//Tab//"StdErr' )"
         WRITE (Unit,FormStr)

         Frmt = "( A, 4('"//Tab//"',"//RealFmt//"))"

      ELSE

         WRITE (Unit,'()')
         FormStr = "(11X,2"//TextFmt//",3X,2"//TextFmt//")"
         WRITE (Unit,FormStr)  'ExpectdVal', '    StdErr', '  Variance', '     StdErr'
         WRITE (Unit,FormStr)  '----------', '    ------', '  --------', '     ------'

         Frmt = "(A,3X,2("//RealFmt//"),3X,2("//RealFmt//"))"

      ENDIF

      WRITE (Unit,Frmt)  ' Minimum', ExtrapMin(IExt), MinStdErr(IExt), MinVar(IExt), MinErrVar(IExt)
      WRITE (Unit,Frmt)  ' Maximum', ExtrapMax(IExt), MaxStdErr(IExt), MaxVar(IExt), MaxErrVar(IExt)


   ENDDO ! IExt


      ! Sort the maximums and minimums for output

   DO IFi = 1, GoodFiles

      IF (ES_Col > NumCols .AND. ES_Col <= NumCols+NumAACols) THEN
         SortMaxs (IFi) = DataMaxs (AA_Cols(ES_Col - NumCols), IFi)
         SortMins (IFi) = DataMins (AA_Cols(ES_Col - NumCols), IFi)
      ELSE
         SortMaxs (IFi) = DataMaxs (ES_Col, IFi)
         SortMins (IFi) = DataMins (ES_Col, IFi)
      ENDIF

   ENDDO  ! IFi

   CALL SORT ( GoodFiles, SortMins )

   CALL SORT ( GoodFiles, SortMaxs )

      WRITE (Unit,'(//,A)')  'Sorted data used in the extrapolation and estimated' &
                           //' quantiles.'

      ! Write the column headings and data for the data distribution.

   IF ( TabDelim )  THEN

      WRITE (Unit,'(/,A)')  "Percentile"//Tab//"Minima"//Tab//"MinEst"//Tab//"MinStdErr"//Tab//"Maxima"//Tab//"MaxEst"//Tab &
                            //"MaxStdErr"

      Frmt = "(F6.3,6('"//Tab//"',"//RealFmt//"))"

   ELSE

      Frmt = "(A,3X,3"//TextFmt//",3X,3"//TextFmt//")"

      WRITE (Unit,'()')
      WRITE (Unit,Frmt)  ' Percentile', '    Minima', '    MinEst', '    StdErr', '    Maxima', '    MaxEst', '    StdErr'
      WRITE (Unit,Frmt)  ' ----------', '    ------', '    ------', '    ------', '    ------', '    ------', '    ------'

      Frmt = "(F11.3,3X,3"//RealFmt//",3X,3"//RealFmt//")"

   ENDIF


     ! The Minima need to be output in reverse of the sort order to get percentiles right.

   IF ( MinDist(1) > MinDist(GoodFiles) ) THEN

      DO IQ=1, GoodFiles

         Quantile = REAL( IQ )/REAL( GoodFiles + 1 )
         WRITE (Unit,Frmt)  Quantile * 100 , SortMins(GoodFiles + 1 - IQ),&
               MinDist(IQ), MinErrDist(IQ), SortMaxs(IQ), MaxDist(IQ), MaxErrDist(IQ)
      ENDDO  ! IQ

   ELSE

      DO IQ=1, GoodFiles

         Quantile = REAL( IQ )/REAL( GoodFiles + 1 )
         WRITE (Unit,Frmt)  Quantile * 100 , SortMins(GoodFiles + 1 - IQ),&
              MinDist(GoodFiles + 1 - IQ), MinErrDist(GoodFiles + 1 - IQ),&
                                             SortMaxs(IQ), MaxDist(IQ), MaxErrDist(IQ)
      ENDDO  ! IQ

   ENDIF


      ! If all of the requested input files could not be read for aggregate analyses,
      ! append the list of bad files to the output.

   IF ( Aggregate .AND. ( BadFiles > 0 ) )  CALL WrBadList ( Unit )


      ! Close output file.

   CLOSE ( Unit )


      ! Deallocate space for arrays.

   DEALLOCATE ( SortMins   )
   DEALLOCATE ( SortMaxs   )
   DEALLOCATE ( MinDist    )
   DEALLOCATE ( MaxDist    )
   DEALLOCATE ( MinErrDist )
   DEALLOCATE ( MaxErrDist )

   RETURN
   END SUBROUTINE ExtrapOpen ! (IC)
!=======================================================================
   SUBROUTINE Extrap2 (IC, Factor, MeanExtrap, StdErrExt, MeanVar, StdErrVar, MeanDist, StdErrDist)


      ! This routine estimates expected maximums using Peter Hauge Madsen's method
      ! with a little help from Steve Winterstein and the Stanford team


   USE                                DataMod
   USE                                ProgGen


      ! Argument declarations.

   REAL(Reki), INTENT(IN)          :: Factor
   REAL(Reki), INTENT(OUT)         :: MeanDist  (GoodFiles)
   REAL(Reki), INTENT(OUT)         :: MeanExtrap(4)
   REAL(Reki), INTENT(OUT)         :: MeanVar   (4)
   REAL(Reki), INTENT(OUT)         :: StdErrDist(GoodFiles)
   REAL(Reki), INTENT(OUT)         :: StdErrExt (4)
   REAL(Reki), INTENT(OUT)         :: StdErrVar (4)

   INTEGER, INTENT(IN)             :: IC


      ! Local declarations.

   REAL(Reki)                      :: Alpha
   REAL(Reki)                      :: Beta
   REAL(Reki)                      :: Dist      (GoodFiles,GoodFiles)
   REAL(Reki)                      :: Euler
   REAL(Reki)                      :: Epsilon
   REAL(Reki)                      :: Extr
   REAL(Reki)                      :: ExtrapEst (4)
   REAL(Reki)                      :: k         (4)
   REAL(Reki)                      :: kq
   REAL(Reki)                      :: Quantile
   REAL(Reki)                      :: Radicand
   REAL(Reki)                      :: TLen
   REAL(Reki)                      :: Var
   REAL(Reki)                      :: VarEst    (4)

   REAL(DbKi)                      :: SumDist
   REAL(DbKi)                      :: SumDist2
   REAL(DbKi)                      :: SumExt    (4)
   REAL(DbKi)                      :: SumExt2   (4)
   REAL(DbKi)                      :: SumVar    (4)
   REAL(DbKi)                      :: SumVar2   (4)

   INTEGER                         :: AACol
   INTEGER                         :: Col
   INTEGER                         :: IExt
   INTEGER                         :: IFi
   INTEGER                         :: IQ


      ! Initialize constants and variables

   Col      = ES_Cols(IC)
   Euler    = 0.5772

   TLen = ConvData(TimeCol,NumRecs,1) - TStart  !Time length of one data file (All should be equal)

   IF ((Col > NumCols) .AND. (Col <= NumCols + NumAACols)) THEN
      AACol = Col - NumCols
      Col = AA_Cols(AACol)
   ELSE
      AACol = 0
   ENDIF

   DO IExt = 1, 4
      SumExt (IExt) = 0.0d0
      SumExt2(IExt) = 0.0d0
      SumVar (IExt) = 0.0d0
      SumVar2(IExt) = 0.0d0
   END DO ! IExt


      ! Find the extrapolation factor
   Extr = ExtHrs(IC) * 60.0 * 60.0 / TLen

      ! Let's find the value of k at 1, T and N times the basis period, and for a given percentile
   k(1) = Euler                        !Expected value for the base period
   k(2) = -LOG(LOG(1.0/Quant(IC)))     !Value for the given quantile during the base period
   k(3) = Euler + LOG(Extr)            !N-Extrapolation (Expected value during N times base period)
   k(4) = Euler                        !T-Extrapolation

      ! Calculate the expected values for each data set

   DO IFi = 1,GoodFiles

      Epsilon  = SIGN(MIN(ABS(Skewness(Col,IFi))/6.0, 0.2), Skewness(Col,IFi))  !Peter's analysis set a limit on epsilon
      CALL FindEps ( Skewness(Col,IFi) , Epsilon )
      Radicand = SQRT(2.0 * LOG(XFreq(Col,IFi) * TLen))
      Alpha    = Radicand/(1 + 2 * Factor * Epsilon * Radicand)
      Beta     = Radicand + Factor * Epsilon * (Radicand*Radicand - 1)


      DO IQ = 1, GoodFiles

        Quantile = Float( IQ )/Float( GoodFiles + 1 )
        kq = -LOG(LOG(1.0/Quantile))

        IF (AACol /= 0) THEN

           CALL AA_Extrap(kq, Radicand, Dist(IFi,IQ), Var, Factor, AACol, IFi)

       ELSE

          Dist(IFi,IQ) = DataMeans(Col,IFi) + Factor * StdDev(Col,IFi) * (Beta + kq/Alpha)

       ENDIF

      ENDDO  ! IQ

      DO IExt = 1, 4

        ! Must recalculate parameters for T-Extrapolation
        IF ( IExt == 4 ) THEN
           Radicand = SQRT(2.0 * LOG(XFreq(Col,IFi) * TLen * Extr))
           Alpha    = Radicand/(1 + 2 * Factor * Epsilon * Radicand)
           Beta     = Radicand + Factor * Epsilon * (Radicand*Radicand - 1)
       ENDIF

        IF (AACol /= 0) THEN

           CALL AA_Extrap(k(IExt), Radicand, ExtrapEst(IExt), VarEst(IExt), Factor, AACol, IFi)

       ELSE

           ExtrapEst(IExt) = DataMeans(Col,IFi) + Factor * StdDev(Col,IFi) * (Beta + k(IExt)/Alpha)
           VarEst (IExt)  = Pi * Pi * StdDev(Col,IFi) * StdDev(Col,IFi)/ (6.0 * Alpha * Alpha)

        ENDIF

       SumExt (IExt) = SumExt (IExt) + ExtrapEst(IExt)
       SumExt2(IExt) = SumExt2(IExt) + ExtrapEst(IExt) * ExtrapEst(IExt)

        SumVar (IExt)  = SumVar(IExt)  + VarEst(IExt)
        SumVar2(IExt)  = SumVar2(IExt) + VarEst(IExt) * VarEst(IExt)

      ENDDO ! IExt



   END DO  ! IFi


      ! Find the mean and standard error of the expected values
   DO IExt = 1, 4

      IF ( GoodFiles > 1 ) Then

         MeanExtrap(IExt) = SumExt(IExt) / Float(GoodFiles)

         StdErrExt (IExt) = SQRT( ( Float(GoodFiles) * Sngl(SumExt2(IExt) ) - &
                                  ( Sngl(SumExt(IExt)) * Sngl(SumExt(IExt)) ) ) / &
                                  (Float(GoodFiles) * Float(GoodFiles - 1))) / &
                                   SQRT(Float(GoodFiles))

         MeanVar(IExt) = SumVar(IExt) / Float(GoodFiles)

         StdErrVar(IExt) = SQRT( ( Float(GoodFiles) * Sngl(SumVar2(IExt)) - &
                                  ( Sngl(SumVar(IExt)) * Sngl(SumVar(IExt)) ) ) / &
                                  (Float(GoodFiles) * Float(GoodFiles - 1))) / &
                                   SQRT(Float(GoodFiles))

      ELSE

         MeanExtrap(IExt) = SumExt(IExt)

         StdErrExt (IExt) = 0.0

         MeanVar(IExt) = SumVar(IExt)

         StdErrVar(IExt) = 0.0

      ENDIF

   ENDDO ! IExt

      ! Find the mean and standard error values for each quantile
   DO IQ = 1, GoodFiles

      SumDist  = 0.0d0
      SumDist2 = 0.0d0

      DO IFi = 1,GoodFiles

        SumDist  = SumDist  + Dist(IFi,IQ)
        SumDist2 = SumDist2 + Dist(IFi,IQ) * Dist(IFi,IQ)

      END DO  ! IFi

      IF ( GoodFiles > 1 ) Then

         MeanDist(IQ) = Sngl(SumDist) / Float(GoodFiles)
         StdErrDist(IQ) = SQRT( ( Float(GoodFiles) * Sngl(SumDist2) - &
                               ( Sngl(SumDist) * Sngl(SumDist)) ) / &
                               (Float(GoodFiles) * Float(GoodFiles - 1))) / &
                                SQRT(Float(GoodFiles))

      ELSE

         MeanDist(IQ) = Sngl(SumDist)
         StdErrDist(IQ) = 0.0

      ENDIF

   ENDDO  ! IQ


      ! Find the mean and standard error of the variance
   IF ( GoodFiles > 1 ) Then

      MeanVar = SumVar / Float(GoodFiles)
      StdErrVar = SQRT( ( Float(GoodFiles) * Sngl(SumVar2) - &
                               ( Sngl(SumVar) * Sngl(SumVar)) ) / &
                               (Float(GoodFiles) * Float(GoodFiles - 1))) / &
                                SQRT(Float(GoodFiles))

   ELSE

      MeanVar = SumVar
      StdErrVar = 0.0

   ENDIF

   RETURN
   END SUBROUTINE Extrap2 ! (IC, Factor, MeanExtrap, StdErrExt, MeanVar, StdErrVar, MeanDist, StdErrDist)
!=======================================================================
   SUBROUTINE AA_Extrap (k, Radicand, ExtrapEst, VarEst, Factor, Col, IFi)


      ! This routine estimates expected maximums using Peter Hauge Madsen's
      ! azimuth binning method


   USE                                DataMod
   USE                                ProgGen


      ! Argument declarations.

   REAL(ReKi), INTENT(IN)          :: k
   REAL(ReKi), INTENT(OUT)         :: ExtrapEst
   REAL(ReKi), INTENT(IN)          :: Factor
   REAL(ReKi), INTENT(IN)          :: Radicand
   REAL(ReKi), INTENT(OUT)         :: VarEst

   INTEGER, INTENT(IN)             :: Col
   INTEGER, INTENT(IN)             :: IFi


      ! Local declarations.

   REAL(ReKi)                      :: Alpha
   REAL(ReKi),ALLOCATABLE          :: Alpha1    (:)
   REAL(ReKi)                      :: AlphaHat
   REAL(ReKi)                      :: Beta
   REAL(ReKi),ALLOCATABLE          :: Beta1     (:)
   REAL(ReKi),ALLOCATABLE          :: Beta2     (:)
   REAL(ReKi)                      :: BetaHat
   REAL(ReKi)                      :: Euler
   REAL(ReKi)                      :: Epsilon
   REAL(ReKi)                      :: Fi1
   REAL(ReKi)                      :: Fi2
   REAL(ReKi)                      :: Max1
   REAL(ReKi)                      :: Max2

   INTEGER                         :: IB
   INTEGER                         :: Sttus


      ! Allocate some array space.

   ALLOCATE ( Alpha1(NumAABins) , STAT=Sttus )

   IF ( Sttus /= 0 )  THEN
      CALL ProgAbort ( ' Error allocating memory for the azimuth binning Alpha1 array.' )
   ENDIF

   ALLOCATE ( Beta1(NumAABins) , STAT=Sttus )

   IF ( Sttus /= 0 )  THEN
      CALL ProgAbort ( ' Error allocating memory for the azimuth binning Beta1 array.' )
   ENDIF

   ALLOCATE ( Beta2(NumAABins) , STAT=Sttus )

   IF ( Sttus /= 0 )  THEN
      CALL ProgAbort ( ' Error allocating memory for the azimuth binning Beta2 array.' )
   ENDIF

      ! Initialize constants and variables

   Euler   = 0.5772
   Epsilon = 0.00

   Max1 = 0.0
   Max2 = 0.0

   Fi1 = 0.0
   Fi2 = 0.0

      ! Calculate the expected values for each data set

   Alpha    = Radicand/(1 + 2 * Factor * Epsilon * Radicand)
   Beta     = Radicand + Factor * Epsilon * (Radicand*Radicand - 1)

   DO IB=1,NumAABins

      Alpha1(IB) = Alpha / (Factor * AziStDev(Col,IB,IFi))
      Beta1 (IB) = AziAver(Col,IB,IFi) + Factor * AziStDev(Col,IB,IFi)*(Beta - LOG(Float(NumAABins))/Alpha)
      Beta2 (IB) = AziAver(Col,IB,IFi) + Factor * AziStDev(Col,IB,IFi)*(Beta)

      IF (Factor > 0.0) THEN  ! we're calculating the maximums

         IF ((Beta1(IB) + Euler / Alpha1(IB)) > Max1) THEN
            Max1 = Beta1(IB) + Euler / Alpha1(IB)
         ENDIF

         IF ((Beta2(IB) + Euler / Alpha1(IB)) > Max2) THEN
            Max2 = Beta2(IB) + Euler / Alpha1(IB)
         ENDIF

      ELSE  ! we're calculating the minimums

         IF ((Beta1(IB) + Euler / Alpha1(IB)) < Max1) THEN
            Max1 = Beta1(IB) + Euler / Alpha1(IB)
         ENDIF

         IF ((Beta2(IB) + Euler / Alpha1(IB)) < Max2) THEN
            Max2 = Beta2(IB) + Euler / Alpha1(IB)
         ENDIF

      ENDIF

   END DO ! IB

   DO IB=1,NumAABins

      Fi1 = Fi1 + EXP(-Alpha1(IB) * (Max1 - Beta1(IB)))
      Fi2 = Fi2 + EXP(-Alpha1(IB) * (Max2 - Beta1(IB)))

   END DO ! IB

   Fi1 = -LOG(Fi1)
   Fi2 = -LOG(Fi2)

   AlphaHat = (Fi2 - Fi1) / (Max2 - Max1)
   BetaHat  = (AlphaHat * Max1 - Fi1) / AlphaHat

   ExtrapEst = BetaHat + k / AlphaHat
   VarEst    = Pi * Pi / (6.0 * AlphaHat * AlphaHat)


   DEALLOCATE ( Alpha1 )
   DEALLOCATE ( Beta1  )
   DEALLOCATE ( Beta2  )

   RETURN
   END SUBROUTINE AA_Extrap ! (k, Radicand, ExtrapEst, VarEst, Factor, Col, IFi)
!=======================================================================
   SUBROUTINE FindEps ( Skew, Epsilon)

      ! This routine finds a value for epsilon by iterating on skewness
      ! using equation (36) form Peter Madsen's report.

   USE                                NWTC_Library


      ! Argument declarations.

   REAL(ReKi), INTENT(INOUT)       :: Epsilon
   REAL(ReKi), INTENT(INOUT)       :: Skew


      ! Local declarations.

   REAL(ReKi)                      :: NewEps



   IF ( ABS(Skew) > 2.5 ) THEN

      CALL WrScr ( ' The Skewness is too large in subroutine FindEps.  Resetting to 2.5' )
      Skew = SIGN(2.5, Skew)

   ENDIF

     ! Initialize NewEps
   NewEps = 0.2

   DO WHILE ( ABS(NewEps - Epsilon) > 0.0000001 )

      Epsilon = NewEps
      NewEps = Skew *(1.0 + 2.0 * Epsilon * Epsilon)**1.5 / &
                     (6.0 + 8.0 * Epsilon * Epsilon)

   END DO

   Epsilon = NewEps

   RETURN
   END SUBROUTINE FindEps ! ( Skew, Epsilon)
!=======================================================================
   SUBROUTINE Sort ( N, Arr )


      ! This routine sorts an array in ascending order.
      ! Based on straight insertion routine in "Numerical Recipes in Fortran"

   USE                                NWTC_Library


      ! Argument declarations.

   INTEGER, INTENT(IN)             :: N

   REAL(ReKi), INTENT(INOUT)       :: Arr (N)


      ! Local declarations.

   REAL(ReKi)                      :: A

   INTEGER                         :: I
   INTEGER                         :: J



   Outer: DO J = 2, N
      A = Arr( J )
      Inner: DO I = J-1, 1, -1
         IF ( Arr( I ) <= A ) THEN
           Arr( I + 1 ) = A
          CYCLE Outer
        ENDIF
        Arr( I + 1 ) = Arr( I )
      ENDDO Inner  ! I
      I = 0
      Arr( I + 1 ) = A
   ENDDO Outer

   RETURN
   END SUBROUTINE Sort ! ( N, Arr )
!=======================================================================

END MODULE ExtrValuSubs
